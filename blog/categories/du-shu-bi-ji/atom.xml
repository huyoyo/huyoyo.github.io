<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 读书笔记 | 胡某某同学]]></title>
  <link href="http://huyoyo.github.io/blog/categories/du-shu-bi-ji/atom.xml" rel="self"/>
  <link href="http://huyoyo.github.io/"/>
  <updated>2017-09-04T23:49:45+08:00</updated>
  <id>http://huyoyo.github.io/</id>
  <author>
    <name><![CDATA[胡某某同学啊]]></name>
    <email><![CDATA[hujieqiong@sjtu.edu.cn]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[javaScript学习笔记(二)]]></title>
    <link href="http://huyoyo.github.io/blog/2017/03/12/javascriptbi-ji/"/>
    <updated>2017-03-12T10:57:09+08:00</updated>
    <id>http://huyoyo.github.io/blog/2017/03/12/javascriptbi-ji</id>
    <content type="html"><![CDATA[<p>最近心态不好，莫名其妙忙成狗啊。有项目压力，还要找符合自己的论文paper，最重要的是还有实习面试材料要准备。基础不牢靠背书啊啊啊啊，胡宝宝的心里压力“咚”大好嘛。趁着有时间，把看书的笔记摘摘～<!--more--></p>

<h4>阅读书目</h4>

<p>《javaScript学习指南》</p>

<h4>重点摘要</h4>

<ul>
<li>函数类型有三种：</li>
</ul>


<p><strong>声明式函数</strong> 拥有自己语句的函数，最开始是关键字function。声明型函数只会解析一次，它是静态的，并且只提供一个名称以便访问它；</p>

<pre><code>function add(m,n){
aler(m+n);
}
</code></pre>

<p>这种方式等同于构造一个function类的实例的方式:</p>

<pre><code>var add=new Function("m","n","alert(m+n);");
</code></pre>

<p>Function类构造方法的最后一个参数为函数体："alert(m+n);&ldquo;，前面的都是函数的形参，参数必须是字符串形式的："m&rdquo;,&ldquo;n"。</p>

<p><strong>匿名函数</strong> 使用构造函数创建的函数。每次访问它时都将解析一次，并且没有指定函数名称;(上述为举例说明)</p>

<pre><code>//创建一个函数，它的参数是一个数据对象和一个函数，
它将对这个数据对象调用该函数
function invokeFunction(dataObject,functionTocall)
{ functionTocall(dataObject);
}
var funCall=new Function('x','alert(x)');
invokeFunction('hello',funCall);
</code></pre>

<p><strong>函数字面量或函数表达式</strong> 在其他语句或表达式中创建的函数。它只会解析一次，它是静态的，可以指定也可以不制定一个特定的函数名称。如果它是已命名的，那么只能在其定义的函数体内访问它</p>

<pre><code>function outerFun(base){
   var test1="!";
   //返回内部函数
   return function(ext){
   return base+ext+test1;
   }
}
//调用事例：
var baseString=outerFun('hello ');
var newString=baseString('you ');
alert(newString);
//输出结果为： hello you !
</code></pre>

<p><code>javaScript闭包</code>:当一个内部函数是外部应用程序的返回值，并赋值给一个外部变量的时候，<strong>内部函数的作用域将附加到外部函数上</strong>然后再附加到主调应用程序中，这样才能保证<strong>内部函数和外部函数参数和变量的完整性</strong>返回再其他函数中以内部对象形式创建的一个函数字面量，然后将其赋值给主调应用程序中的一个变量，它将引入一个作用域链的概念，它是确保应用程序在本地能够正常工作所需的数据。</p>

<ul>
<li>浏览器兼容性检查通用方法</li>
</ul>


<p><strong>编写一段跨浏览器兼容代码，检查浏览器是否支持该元素</strong></p>

<p>测试一个是否支持HTML5 element,基本前提是：</p>

<pre><code>1. 使用document.createElement()动态创建该元素，判断浏览器是否支持它。
2. 测试新创建对象的一个已知属性或js方法是否存在，来判断是否浏览器真的支持该元素。
3. 对应input元素，设置你要测试的input元素的Type 属性，然后看浏览器是否保留该值。
</code></pre>

<p><strong>一个例子</strong></p>

<pre><code>//测试是否在style对象中实现了textShadow
var headerElement=doucument.getElementById("pageHeader");
headerElement.style.textShadow="#ff0000 2px 2px 3px";
</code></pre>

<ul>
<li>DOM Level2 事件模型</li>
</ul>


<p><strong>支持事件捕获（前远后近）和事件冒泡</strong>两种处理方式</p>

<pre><code>//level0和2指定一个事件的区别
document.onclick=clickFunc;
document.addEventListener("click", clickFunc,false);

//考虑代码能安全的运行在所有浏览器上   
if(document.addEventListener)
{
  document.addEventListener("click", clickFunc,false);
  }
  else if(document.attachEvent){
document.attachEvent("onclick", clickFunc); 
}else if(document.onclick)
{
 document.onclick=clickFunc;
  }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javaScript读书笔记(一)]]></title>
    <link href="http://huyoyo.github.io/blog/2017/01/26/javascriptdu-shu-bi-ji-%5B%3F%5D/"/>
    <updated>2017-01-26T12:08:03+08:00</updated>
    <id>http://huyoyo.github.io/blog/2017/01/26/javascriptdu-shu-bi-ji-[?]</id>
    <content type="html"><![CDATA[<p>虽然写过一点前端的项目，但是一直在别人搭好的框架上进行coding。前端知识并不好，基础不牢总是要付出代价的TT.从头开始补基础，从javaScript开始。<!--more--></p>

<h4>设计意图</h4>

<p>javaScript最初设计意图就是为了在浏览器端中载入的Web页面和位于服务器上的应用程序之间提供脚本化的接口。</p>

<h4>阅读书目</h4>

<p>《javaScript学习指南》</p>

<h4>基础知识摘要</h4>

<p>最好保持脚本位置的一致性，要么全部放在head元素中，要么全部放在body元素的最末尾处</p>

<p>常见事件处理程序</p>

<pre><code>onclick     点击事件
onmouseover 当鼠标停留在某元素上触发
onmousemout 当鼠标离开某元素时触发
onfocus     当某元素获得焦点时触发
</code></pre>

<ul>
<li>document对象的所有目的时呈现整个页面，包括页面中的所有元素；</li>
<li>脚本引用example：<script type="text/javascript" src="test.js"></script></li>
<li>转义符 反斜杠 \</li>
<li>对于非ascii码－－encodeURI/encodeURIComponent对字符串进行编码，转换成URIencoding字符（decodeURI/decodeURIComponent）</li>
<li><code>双重否定符</code>（!!）可以用来显示地将数字或字符串转换为布尔值</li>
<li>javascript<code>除法</code>得到的结果是浮点型数字</li>
</ul>


<h4>Boolean对象</h4>

<ul>
<li><code>Boolean对象</code>实例，对象初始值为<code>空字符串</code>时候则对象的初始值将为<code>fasle</code>,任何<code>非空字符串</code>创建boolean对象实例初始值为<code>true</code>.</li>
</ul>


<h4>String对象</h4>

<ul>
<li>常用方法</li>
</ul>


<table>
        <tr>
            <th>方法</th>
            <th>描述</th>
            <th>参数</th>
          </tr>
        <tr>
            <th>contact</th>
            <th>连接字符串</th>
            <th>字符串参数，把该字符串连接到string对象的字面量字符串</th>
        </tr>
        <tr>
            <th>split</th>
            <th>根据特定的分割符，字符串分割</th>
            <th>分割符和分割最大数目</th>
                 </tr>
        <tr>
            <th>slice</th>
            <th>返回字符串的某个片段</th>
            <th>该片段的起始和结束位置</th>
                  </tr>
                    <tr>
            <th>toLowerCase
            toUpperCase</th>
            <th>大小写转换</th>
            <th>无</th>
                  </tr>
    </table>


<h4>正则表达式和RegExp</h4>

<ul>
<li>RegExp方法：test匹配考虑大小写，加i则忽略大小写,g表示全局匹配 /xxx/ig exec返回结果是一个数组，并存储圆括号包含的子字符串</li>
<li>＊表示前面*字符出现零次或多次；+前面字符出现一次或多次；？字符出现0次或1次；.表示字符只出现一次;^脱字符［<sup>0</sup>-9］表示非数字字符; ^和$表示一行的开始和结束;\w匹配任何数字字母字符，包括下划线[A-Za-z0-9];｜表示可以选择;｛｝表示前面字符重复的次数</li>
</ul>


<h4>FIFO队列</h4>

<pre><code>shift方法   移除数组第一个元素 
unshift方法 将元素添加到数组开
</code></pre>
]]></content>
  </entry>
  
</feed>
